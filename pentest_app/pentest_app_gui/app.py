import eventlet
eventlet.monkey_patch()
from flask import Flask, render_template, request, redirect, url_for, flash
import os
import sys
import threading
import time
from flask_socketio import SocketIO, emit

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from pentest_app.reconnaissance import scan_port, scan_icmp, service_version
from pentest_app.bruteforce import permutation, dictionnaire
from pentest_app.vulnerabilite import detection_failles, detection_port, service_obsolete
from pentest_app.postexploitation import analyse_reseau, dump_session, exploration_reseau
from pentest_app.evasion import bypass_firewall, antivirus_evasion, IDS_evasion

app = Flask(__name__)
app.secret_key = 'pentest_secret_key'
socketio = SocketIO(app, async_mode='eventlet')
CANCEL_FLAGS = {}

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/reconnaissance', methods=['GET', 'POST'])
def reconnaissance():
    if request.method == 'POST':
        # Traiter les données du formulaire si besoin
        pass
    return render_template('reconnaissance.html')

@socketio.on('launch_recon')
def handle_recon(data):
    target = data.get('target')
    mode = data.get('mode')
    outil = data.get('outil', 'scapy')
    ports = data.get('ports', '')
    port = int(data.get('port', 0)) if data.get('port') else None
    subtest = data.get('subtest', 'banner')
    sid = request.sid
    CANCEL_FLAGS[sid] = False
    def run():
        socketio.emit('log', {'msg': f"[+] Lancement du test sur {target}"}, to=sid)
        time.sleep(0.5)
        if mode == 'scan_port':
            ports_list = [int(p.strip()) for p in ports.split(',')] if ports else []
            use_nmap = outil == 'nmap'
            socketio.emit('log', {'msg': f"[+] Scan de port en cours..."}, to=sid)
            scan_port.scan_ports(target, ports_list, use_nmap=use_nmap, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid), should_stop=lambda: CANCEL_FLAGS.get(sid, False))
        elif mode == 'scan_icmp':
            use_nmap = outil == 'nmap'
            socketio.emit('log', {'msg': f"[+] Scan ICMP en cours..."}, to=sid)
            scan_icmp.scan_icmp(target, use_nmap=use_nmap, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'service_version':
            use_nmap = outil == 'nmap'
            socketio.emit('log', {'msg': f"[+] Détection service/version en cours..."}, to=sid)
            if subtest == 'banner' or use_nmap:
                service_version.detect_service_version(target, port=port, use_nmap=use_nmap, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
            elif subtest == 'ftp_anonymous':
                service_version.ftp_anonymous_access(target, port=21, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
            elif subtest == 'ftp_bruteforce':
                service_version.brute_force_ftp(target, port=21, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        socketio.emit('end', {'msg': "Test terminé."}, to=sid)
        CANCEL_FLAGS.pop(sid, None)
    threading.Thread(target=run).start()

@app.route('/bruteforce', methods=['GET', 'POST'])
def bruteforce():
    result = None
    if request.method == 'POST':
        target = request.form['target']
        username = request.form['username']
        wordlist = request.form['wordlist']
        port = int(request.form.get('port', 22))
        mode = request.form['mode']
        outil = request.form.get('outil', 'paramiko')
        if mode == 'permutation':
            use_hydra = outil == 'hydra'
            result = permutation.brute_force_permutation(target, username, use_hydra=use_hydra)
        elif mode == 'dictionnaire':
            use_hydra = outil == 'hydra'
            result = dictionnaire.brute_force_dictionnaire(target, username, wordlist, use_hydra=use_hydra, port=port)
    return render_template('bruteforce.html', result=result)

@app.route('/vulnerabilite', methods=['GET', 'POST'])
def vulnerabilite():
    result = None
    if request.method == 'POST':
        target = request.form['target']
        mode = request.form['mode']
        outil = request.form.get('outil', 'scapy')
        if mode == 'failles':
            result = detection_failles.detect_failles(target, outil=outil)
        elif mode == 'ports':
            result = detection_port.detect_ports_non_securises(target, outil=outil)
        elif mode == 'obsoletes':
            result = service_obsolete.detect_services_obsoletes(target, outil=outil)
    return render_template('vulnerabilite.html', result=result)

@app.route('/postexploitation', methods=['GET', 'POST'])
def postexploitation():
    result = None
    if request.method == 'POST':
        subnet = request.form['subnet']
        mode = request.form['mode']
        if mode == 'analyse':
            result = analyse_reseau.analyse_reseau_interne(subnet)
        elif mode == 'dump':
            result = dump_session.dump_sessions()
        elif mode == 'exploration':
            result = exploration_reseau.exploration_reseau_interne(subnet)
    return render_template('postexploitation.html', result=result)

@app.route('/evasion', methods=['GET', 'POST'])
def evasion():
    result = None
    if request.method == 'POST':
        target = request.form['target']
        mode = request.form['mode']
        if mode == 'firewall':
            result = bypass_firewall.bypass_firewall(target)
        elif mode == 'antivirus':
            result = antivirus_evasion.antivirus_evasion()
        elif mode == 'ids':
            result = IDS_evasion.IDS_evasion(target)
    return render_template('evasion.html', result=result)

@socketio.on('launch_brute')
def handle_brute(data):
    target = data.get('target')
    username = data.get('username')
    port = int(data.get('port', 22))
    wordlist = data.get('wordlist')
    mode = data.get('mode')
    outil = data.get('outil', 'paramiko')
    sid = request.sid
    CANCEL_FLAGS[sid] = False
    def run():
        socketio.emit('log', {'msg': f"[+] Lancement brute force sur {target}"}, to=sid)
        time.sleep(0.5)
        use_hydra = outil == 'hydra'
        if mode == 'permutation':
            socketio.emit('log', {'msg': f"[+] Attaque permutation en cours..."}, to=sid)
            permutation.brute_force_permutation(target, username, use_hydra=use_hydra, port=port, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid), should_stop=lambda: CANCEL_FLAGS.get(sid, False))
        elif mode == 'dictionnaire':
            socketio.emit('log', {'msg': f"[+] Attaque dictionnaire en cours..."}, to=sid)
            dictionnaire.brute_force_dictionnaire(target, username, wordlist, use_hydra=use_hydra, port=port, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid), should_stop=lambda: CANCEL_FLAGS.get(sid, False))
        socketio.emit('end', {'msg': "Test terminé."}, to=sid)
        CANCEL_FLAGS.pop(sid, None)
    threading.Thread(target=run).start()

@socketio.on('launch_vuln')
def handle_vuln(data):
    target = data.get('target')
    mode = data.get('mode')
    outil = data.get('outil', 'scapy')
    sid = request.sid
    CANCEL_FLAGS[sid] = False
    def run():
        socketio.emit('log', {'msg': f"[+] Lancement vulnérabilité sur {target}"}, to=sid)
        time.sleep(0.5)
        if mode == 'failles':
            socketio.emit('log', {'msg': f"[+] Détection de failles en cours..."}, to=sid)
            detection_failles.detect_failles(target, outil=outil, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'ports':
            socketio.emit('log', {'msg': f"[+] Détection ports/services non sécurisés..."}, to=sid)
            detection_port.detect_ports_non_securises(target, outil=outil, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'obsoletes':
            socketio.emit('log', {'msg': f"[+] Détection services obsolètes..."}, to=sid)
            service_obsolete.detect_services_obsoletes(target, outil=outil, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        socketio.emit('end', {'msg': "Test terminé."}, to=sid)
        CANCEL_FLAGS.pop(sid, None)
    threading.Thread(target=run).start()

@socketio.on('launch_post')
def handle_post(data):
    subnet = data.get('subnet')
    mode = data.get('mode')
    outil = data.get('outil', 'scapy')
    sid = request.sid
    CANCEL_FLAGS[sid] = False
    def run():
        socketio.emit('log', {'msg': f"[+] Lancement post-exploitation sur {subnet}"}, to=sid)
        time.sleep(0.5)
        if mode == 'analyse':
            socketio.emit('log', {'msg': f"[+] Analyse réseau interne..."}, to=sid)
            analyse_reseau.analyse_reseau_interne(subnet, outil=outil, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'dump':
            socketio.emit('log', {'msg': f"[+] Dump de session..."}, to=sid)
            dump_session.dump_sessions(outil=outil, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'exploration':
            socketio.emit('log', {'msg': f"[+] Exploration réseau interne..."}, to=sid)
            exploration_reseau.exploration_reseau_interne(subnet, outil=outil, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        socketio.emit('end', {'msg': "Test terminé."}, to=sid)
        CANCEL_FLAGS.pop(sid, None)
    threading.Thread(target=run).start()

@socketio.on('launch_evasion')
def handle_evasion(data):
    target = data.get('target')
    mode = data.get('mode')
    sid = request.sid
    CANCEL_FLAGS[sid] = False
    def run():
        socketio.emit('log', {'msg': f"[+] Lancement évasion sur {target}"}, to=sid)
        time.sleep(0.5)
        if mode == 'firewall':
            socketio.emit('log', {'msg': f"[+] Bypass Firewall..."}, to=sid)
            bypass_firewall.bypass_firewall(target, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'antivirus':
            socketio.emit('log', {'msg': f"[+] Evasion Antivirus..."}, to=sid)
            antivirus_evasion.antivirus_evasion(progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        elif mode == 'ids':
            socketio.emit('log', {'msg': f"[+] Evasion IDS..."}, to=sid)
            IDS_evasion.IDS_evasion(target, progress_callback=lambda msg: socketio.emit('log', {'msg': msg}, to=sid))
        socketio.emit('end', {'msg': "Test terminé."}, to=sid)
        CANCEL_FLAGS.pop(sid, None)
    threading.Thread(target=run).start()

@socketio.on('stop')
def handle_stop():
    sid = request.sid
    CANCEL_FLAGS[sid] = True
    socketio.emit('log', {'msg': '[!] Arrêt du test demandé...'}, to=sid)

# Répéter la logique pour bruteforce, vulnerabilite, postexploitation, evasion

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5050, debug=True)
