from flask import Flask, render_template, request, redirect, url_for, flash
import os
import sys
import threading
import time
from flask_socketio import SocketIO, emit
import eventlet

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from pentest_app.reconnaissance import scan_port, scan_icmp, service_version
from pentest_app.bruteforce import permutation, dictionnaire
from pentest_app.vulnerabilite import detection_failles, detection_port, service_obsolete
from pentest_app.postexploitation import analyse_reseau, dump_session, exploration_reseau
from pentest_app.evasion import bypass_firewall, antivirus_evasion, IDS_evasion

eventlet.monkey_patch()

app = Flask(__name__)
app.secret_key = 'pentest_secret_key'
socketio = SocketIO(app, async_mode='eventlet')

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/reconnaissance', methods=['GET', 'POST'])
def reconnaissance():
    if request.method == 'POST':
        # Traiter les données du formulaire si besoin
        pass
    return render_template('reconnaissance.html')

@socketio.on('launch_recon')
def handle_recon(data):
    target = data.get('target')
    mode = data.get('mode')
    outil = data.get('outil', 'scapy')
    ports = data.get('ports', '')
    port = int(data.get('port', 0)) if data.get('port') else None
    def run():
        emit('log', {'msg': f"[+] Lancement du test sur {target}"})
        time.sleep(0.5)
        if mode == 'scan_port':
            ports_list = [int(p.strip()) for p in ports.split(',')] if ports else []
            use_nmap = outil == 'nmap'
            emit('log', {'msg': f"[+] Scan de port en cours..."})
            result = scan_port.scan_ports(target, ports_list, use_nmap=use_nmap)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'scan_icmp':
            use_nmap = outil == 'nmap'
            emit('log', {'msg': f"[+] Scan ICMP en cours..."})
            result = scan_icmp.scan_icmp(target) if not use_nmap else os.popen(f"nmap -sn {target}").read()
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'service_version':
            use_nmap = outil == 'nmap'
            emit('log', {'msg': f"[+] Détection service/version en cours..."})
            result = service_version.detect_service_version(target, port=port, use_nmap=use_nmap)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        emit('end', {'msg': "Test terminé."})
    threading.Thread(target=run).start()

@app.route('/bruteforce', methods=['GET', 'POST'])
def bruteforce():
    result = None
    if request.method == 'POST':
        target = request.form['target']
        username = request.form['username']
        wordlist = request.form['wordlist']
        port = int(request.form.get('port', 22))
        mode = request.form['mode']
        outil = request.form.get('outil', 'paramiko')
        if mode == 'permutation':
            use_hydra = outil == 'hydra'
            result = permutation.brute_force_permutation(target, username, use_hydra=use_hydra)
        elif mode == 'dictionnaire':
            use_hydra = outil == 'hydra'
            result = dictionnaire.brute_force_dictionnaire(target, username, wordlist, use_hydra=use_hydra, port=port)
    return render_template('bruteforce.html', result=result)

@app.route('/vulnerabilite', methods=['GET', 'POST'])
def vulnerabilite():
    result = None
    if request.method == 'POST':
        target = request.form['target']
        mode = request.form['mode']
        outil = request.form.get('outil', 'scapy')
        if mode == 'failles':
            result = detection_failles.detect_failles(target, outil=outil)
        elif mode == 'ports':
            result = detection_port.detect_ports_non_securises(target, outil=outil)
        elif mode == 'obsoletes':
            result = service_obsolete.detect_services_obsoletes(target, outil=outil)
    return render_template('vulnerabilite.html', result=result)

@app.route('/postexploitation', methods=['GET', 'POST'])
def postexploitation():
    result = None
    if request.method == 'POST':
        subnet = request.form['subnet']
        mode = request.form['mode']
        if mode == 'analyse':
            result = analyse_reseau.analyse_reseau_interne(subnet)
        elif mode == 'dump':
            result = dump_session.dump_sessions()
        elif mode == 'exploration':
            result = exploration_reseau.exploration_reseau_interne(subnet)
    return render_template('postexploitation.html', result=result)

@app.route('/evasion', methods=['GET', 'POST'])
def evasion():
    result = None
    if request.method == 'POST':
        target = request.form['target']
        mode = request.form['mode']
        if mode == 'firewall':
            result = bypass_firewall.bypass_firewall(target)
        elif mode == 'antivirus':
            result = antivirus_evasion.antivirus_evasion()
        elif mode == 'ids':
            result = IDS_evasion.IDS_evasion(target)
    return render_template('evasion.html', result=result)

@socketio.on('launch_brute')
def handle_brute(data):
    target = data.get('target')
    username = data.get('username')
    port = int(data.get('port', 22))
    wordlist = data.get('wordlist')
    mode = data.get('mode')
    outil = data.get('outil', 'paramiko')
    def run():
        emit('log', {'msg': f"[+] Lancement brute force sur {target}"})
        time.sleep(0.5)
        use_hydra = outil == 'hydra'
        if mode == 'permutation':
            emit('log', {'msg': f"[+] Attaque permutation en cours..."})
            result = permutation.brute_force_permutation(target, username, use_hydra=use_hydra)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'dictionnaire':
            emit('log', {'msg': f"[+] Attaque dictionnaire en cours..."})
            result = dictionnaire.brute_force_dictionnaire(target, username, wordlist, use_hydra=use_hydra, port=port)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        emit('end', {'msg': "Test terminé."})
    threading.Thread(target=run).start()

@socketio.on('launch_vuln')
def handle_vuln(data):
    target = data.get('target')
    mode = data.get('mode')
    outil = data.get('outil', 'scapy')
    def run():
        emit('log', {'msg': f"[+] Lancement vulnérabilité sur {target}"})
        time.sleep(0.5)
        if mode == 'failles':
            emit('log', {'msg': f"[+] Détection de failles en cours..."})
            result = detection_failles.detect_failles(target, outil=outil)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'ports':
            emit('log', {'msg': f"[+] Détection ports/services non sécurisés..."})
            result = detection_port.detect_ports_non_securises(target, outil=outil)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'obsoletes':
            emit('log', {'msg': f"[+] Détection services obsolètes..."})
            result = service_obsolete.detect_services_obsoletes(target, outil=outil)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        emit('end', {'msg': "Test terminé."})
    threading.Thread(target=run).start()

@socketio.on('launch_post')
def handle_post(data):
    subnet = data.get('subnet')
    mode = data.get('mode')
    def run():
        emit('log', {'msg': f"[+] Lancement post-exploitation sur {subnet}"})
        time.sleep(0.5)
        if mode == 'analyse':
            emit('log', {'msg': f"[+] Analyse réseau interne..."})
            result = analyse_reseau.analyse_reseau_interne(subnet)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'dump':
            emit('log', {'msg': f"[+] Dump de session..."})
            result = dump_session.dump_sessions()
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'exploration':
            emit('log', {'msg': f"[+] Exploration réseau interne..."})
            result = exploration_reseau.exploration_reseau_interne(subnet)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        emit('end', {'msg': "Test terminé."})
    threading.Thread(target=run).start()

@socketio.on('launch_evasion')
def handle_evasion(data):
    target = data.get('target')
    mode = data.get('mode')
    def run():
        emit('log', {'msg': f"[+] Lancement évasion sur {target}"})
        time.sleep(0.5)
        if mode == 'firewall':
            emit('log', {'msg': f"[+] Bypass Firewall..."})
            result = bypass_firewall.bypass_firewall(target)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'antivirus':
            emit('log', {'msg': f"[+] Evasion Antivirus..."})
            result = antivirus_evasion.antivirus_evasion()
            for line in result.split('\n'):
                emit('log', {'msg': line})
        elif mode == 'ids':
            emit('log', {'msg': f"[+] Evasion IDS..."})
            result = IDS_evasion.IDS_evasion(target)
            for line in result.split('\n'):
                emit('log', {'msg': line})
        emit('end', {'msg': "Test terminé."})
    threading.Thread(target=run).start()

# Répéter la logique pour bruteforce, vulnerabilite, postexploitation, evasion

if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5000, debug=True)
